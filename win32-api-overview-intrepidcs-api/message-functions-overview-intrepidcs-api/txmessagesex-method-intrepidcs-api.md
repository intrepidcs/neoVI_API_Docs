# TxMessagesEx Method - intrepidcs API

This method transmits longer messages asynchronously to vehicle networks using the neoVI hardware. Method supports CAN FD and Ethernet networks.

{% tabs %}
{% tab title="C/C++ Declare" %}
```cpp
int _stdcall icsneoTxMessagesEx(void * hObject, icsSpyMessage *pMsg, int lNetworkID, int lNumMessages, int *NumTxed, int reserved);
```
{% endtab %}

{% tab title="Visual Basic .NET Declare" %}
```vbnet
Public Declare Function icsneoTxMessagesEx Lib “icsneo40.dll” (ByVal hObject As IntPtr, ByRef pMsg As icsSpyMessage, ByVal lNetworkID As Int32, ByVal lNumMessages As Int32, ByRef NumTxed As Int32, ByVal reserved As Int32) As Int32int _stdcall icsneoTxMessagesEx(void * hObject, icsSpyMessage *pMsg, int lNetworkID, int lNumMessages, int *NumTxed, int reserved);
```
{% endtab %}

{% tab title="C# Declare" %}
```csharp
[DllImport(“icsneo40.dll”)] public static extern Int32 icsneoTxMessagesEx(IntPtr hObject, ref icsSpyMessage pMsg, Int32 lNetworkID, Int32 lNumMessages, ref Int32 NumTxed, Int32 reserved);
```
{% endtab %}
{% endtabs %}

**Parameters**

hObject

\[in] Handle which specifies the driver object created by [OpenNeoDevice](../basic-functions-overview-intrepidcs-api/openneodevice-method-intrepidcs-api.md)

pMsg

\[in] This is the address of the first element of an array of [icsSpyMessage](../structures-types-and-defines-overview-intrepidcs-api/setting-structures-overview-intrepidcs-api/message-structures-neovi-api.md) structures. This array will be loaded by the application software with messages that are to be transmitted by the hardware.

lNetworkID

\[in] Specifies the network to transmit the message on. See [NetworkID List](../structures-types-and-defines-overview-intrepidcs-api/setting-structures-overview-intrepidcs-api/neovi-network-id-list.md) for a list of valid Network ID values. Network support varies by neoVI device. NETID\_DEVICE transmits on to the neoVI Device Virtual Network (see users manual).

lNumMessages

\[in] Specifies the number of messages to be transmitted. This parameter should always be set to one unless you are transmitting a long Message. Transmitting long messages on ISO or J1708 is described in a [different topic](transmitting-long-messages-intrepidcs-api.md).

NumTxed

\[out] Specifies the number of messages that have been transmitted.

reserved

\[in] Reserved parameter for future use. Set to 0.

**Return Values**

Returns 1 if successful, 0 if an error occurred. [GetLastAPIError](../error-functions-overview-intrepidcs-api/getlastapierror-method-intrepidcs-api.md) must be called to obtain the specific error. The errors that can be generated by this function are:

NEOVI\_ERROR\_DLL\_ISOTX\_DATA\_BUFFER\_ALLOC = 13

NEOVI\_ERROR\_DLL\_NEOVI\_NO\_RESPONSE = 75

NEOVI\_ERROR\_DLL\_ILLEGAL\_TX\_NETWORK= 90

NEOVI\_ERROR\_DLL\_3G\_DEVICE\_LICENSE\_NEEDS\_TO\_BE\_UPGRADED = 190

**Remarks**

This function call adds a transmit message to the transmit queue for CAN FD (more than 8 bytes) and Ethernet. The message will be transmitted when the network is free and all previously transmitted messages have been transmitted.

#### Transmit Report

After the messages has been transmitted there will be a transmit report message returned from the device. The transmit report will be read out with [GetMessages](getmessages-method-intrepidcs-api.md). Any message read which has the SPY\_STATUS\_TX\_MSG (icsSpyStatusTx) bit set in the [status bitfield](../structures-types-and-defines-overview-intrepidcs-api/setting-structures-overview-intrepidcs-api/status-bitfields-neovi-api.md) is a transmit report.

You can also identify a particular transmitted message with DescriptionID field. This two byte field (only 14 bits are used) allows the programmer to assign an arbitrary number to a message. This number is then returned in the transmit report.

The transmit report does not necessarily mean the message was transmitted successfully. For example, the Ford SCP network will return a Transmit Report if it had tried to send a message. Therefore, the programmer should always check the GlobalError Flag in the [status bitfield](../structures-types-and-defines-overview-intrepidcs-api/setting-structures-overview-intrepidcs-api/status-bitfields-neovi-api.md).

To transmit different messages, set the appropriate bits in the [status bitfield](../structures-types-and-defines-overview-intrepidcs-api/setting-structures-overview-intrepidcs-api/status-bitfields-neovi-api.md). For example, there are bits for init waveforms, extended identifiers and remote frames.

### Examples

{% tabs %}
{% tab title="C/C++ Example" %}
```cpp
long lResult;
icsSpyMessage stMessagesTx;
int lNetworkID;
unsigned int iNumberTxed;
unsigned char iDataBytes[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63}; //Data to send

//Send on HS CAN
lNetworkID = NETID_HSCAN;

//Set the ID
stMessagesTx.ArbIDOrHeader = 0x123;
stMessagesTx.NumberBytesHeader = 0;
stMessagesTx.StatusBitField = 0; //11 bit ID
stMessagesTx.Protocol = SPY_PROTOCOL_CANFD;
stMessagesTx.StatusBitField3 = 16; //Enable bitrate switch

// The number of Data Bytes
//NOTE: CAN FD is limited to lengths of 0,1,2,3,4,5,6,7,8,12,16,20,24,32,48,64
stMessagesTx.NumberBytesData = 64;

//Enable Extra Data Pointer
stMessagesTx.ExtraDataPtrEnabled = 1;
stMessagesTx.ExtraDataPtr = &iDataBytes;
lResult = icsneoTxMessagesEx(m_hObject, &stMessagesTx, lNetworkID, 1, &iNumberTxed, 0);

if (iResult == 0)
    MessageBox(hWnd,TEXT("Problem Transmitting Messages"),TEXT("neoVI Example"),0);
```
{% endtab %}

{% tab title="Visual Basic .NET Example" %}
```vbnet
Dim lResult As Long
Dim stMessagesTx As New icsSpyMessage
Dim lNetworkID As Integer
Dim iNumberTxed As Int32
Dim sSplitString() As String
Dim iDataBytes() As Byte = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63}
Dim iCounter As Int32


'//Get pointer to data
Dim gcHandle As System.Runtime.InteropServices.GCHandle = System.Runtime.InteropServices.GCHandle.Alloc(iDataBytes, System.Runtime.InteropServices.GCHandleType.Pinned)
Dim CanFDptr As IntPtr = gcHandle.AddrOfPinnedObject

'//Send on HS CAN
lNetworkID = GetNetworkIDfromString(lstCANFDNetwork.Text)

'//Set the ID
stMessagesTx.ArbIDOrHeader = &h7E0

'// The number of Data Bytes
'//NOTE: CAN FD is limited to lengths of 0,1,2,3,4,5,6,7,8,12,16,20,24,32,48,64
stMessagesTx.NumberBytesData = 64

stMessagesTx.NumberBytesHeader = 0
stMessagesTx.iExtraDataPtr = CanFDptr
stMessagesTx.Protocol = SPY_PROTOCOL_CANFD

'//Use Normal ID
stMessagesTx.StatusBitField = 0
stMessagesTx.StatusBitField2 = 0
stMessagesTx.StatusBitField3 = 16 '//Enable bitrate switch

'// Transmit the assembled message
'//CAN FD More than 8 bytes
'//Enable Extra Data Pointer
stMessagesTx.ExtraDataPtrEnabled = 1
lResult = icsneoTxMessagesEx(m_hObject, stMessagesTx, lNetworkID, 1, iNumberTxed, 0)

If Not CBool(lResult) Then
    MsgBox("Problem Transmitting Message")
End If
gcHandle.Free()
```
{% endtab %}

{% tab title="C# Example" %}
```csharp
//Hardware must have CAN FD support for this tor work.

int lResult;
icsSpyMessage stMessagesTx = new icsSpyMessage();
int lNetworkID;
uint iNumberTxed = 0;
byte[] iDataBytes = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};
int iCounter;

//Get pointer to data (could also be done with Unsafe code)
System.Runtime.InteropServices.GCHandle gcHandle = System.Runtime.InteropServices.GCHandle.Alloc(iDataBytes, System.Runtime.InteropServices.GCHandleType.Pinned);
IntPtr CanFDptr = gcHandle.AddrOfPinnedObject();

//Send on HS CAN

string sNetIDToUse = 1;
lNetworkID = icsNeoDll.GetNetworkIDfromString(ref sNetIDToUse);

//Set the ID
stMessagesTx.ArbIDOrHeader = 0x7E0;

// The number of Data Bytes
//NOTE: CAN FD is limited to lengths of 0,1,2,3,4,5,6,7,8,12,16,20,24,32,48,64
stMessagesTx.NumberBytesData = 64;
stMessagesTx.NumberBytesHeader = 0;
stMessagesTx.iExtraDataPtr = CanFDptr;
stMessagesTx.Protocol = Convert.ToByte(CSnet.ePROTOCOL.SPY_PROTOCOL_CANFD);

//Use Normal ID
stMessagesTx.StatusBitField = 0;
stMessagesTx.StatusBitField2 = 0;
stMessagesTx.StatusBitField3 = 16; //Enable bitrate switch

//CAN FD More than 8 bytes
//Enable Extra Data Pointer
stMessagesTx.ExtraDataPtrEnabled = 1;
lResult = icsNeoDll.icsneoTxMessagesEx(m_hObject, ref stMessagesTx, Convert.ToUInt32(lNetworkID), 1, ref iNumberTxed, 0);

// Test the returned result
if (lResult != 1)
{
    MessageBox.Show("Problem Transmitting Message");
}
gcHandle.Free();
```
{% endtab %}
{% endtabs %}
